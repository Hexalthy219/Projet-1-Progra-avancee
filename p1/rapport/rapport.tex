\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Extrait de Code}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} 
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind} 
\usepackage[titles,subfigure]{tocloft} 
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} 

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
    language=C, % Utilisation du langage C
    commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
    frame=single, % Entoure le code d'un joli cadre
    rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
    stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
    numbers=left, % Ajoute une numérotation des lignes à gauche
    numbersep=5pt, % Distance entre les numérots de lignes et le code
    numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
    basicstyle=\tt\footnotesize, 
    tabsize=3, % Largeur des tabulations par défaut
    keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
    extendedchars=true, 
    captionpos=b, % sets the caption-position to bottom
    texcl=true, % Commentaires sur une ligne interprétés en Latex
    showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
    escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
    inputencoding=utf8,
    literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
\newcommand{\intitule}{Projet 1 : Algorithmes de tri}
\newcommand{\GrNbr}{1}
\newcommand{\PrenomUN}{Martin}
\newcommand{\NomUN}{RANDAXHE}
\newcommand{\PrenomDEUX}{Cyril}
\newcommand{\NomDEUX}{RUSSE}
\renewcommand{\tablemat}{\tableofcontents}

\title{\textbf{INFO0250 - Programmation avancée} \\\intitule}
\author{Groupe \GrNbr : \PrenomUN~\textsc{\NomUN}, \PrenomDEUX~\textsc{\NomDEUX}}
\date{}
\begin{document}
\maketitle
\newpage
\tablemat
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
    \section{\textbf{Introduction}}
    \section{\textbf{Algorithmes vus au cours}}
    Dans cette section, nous allons analyser les différents algorithmes 
    ayant été vus lors du cours théorique et implémenté dans le cadre de ce projet.
    Pour ce faire, nous allons présenter les résultats des calculs empiriques des temps 
    d'exécution des 3 algorithmes concernés. Par la suite, nous comparerons l'évolution de ceux-ci 
    par rapport aux complexités théoriques en fonction de la taille du tableau. Et finalement y apporter 
    nos analyses vis à vis de l'ordre relatif de ces différents algorithmes.

    \subsection{Résultats empiriques de temps d'exécution}
    Voici, présenté dans la table ci-dessous, les valeurs de temps d'exécution des 3 algorithmes de tri 
    vus au cours: InsertionSort, QuickSort et HeapSort.(Algorithmes respectivement 
    implémentés dans les fichiers InsertionSort.c, QuickSort.c et HeapSort.C)
    Ces valeurs sont basées sur une moyenne de 10 temps d'execution pour des tableaux 
    de taille $10^3$, $10^4$ et $10^5$.

    \begin{figure}[h]
        \centering
        \begin{tabular}{|l|c|c|c|c|c|c|}
            \cline{1-7}
            Type de tableau&\multicolumn{3}{c|}{aléatoire}&\multicolumn{3}{c|}{croissant}\\
            \cline{1-7}
            Taille&$10^3$&$10^4$&$10^5$&$10^3$&$10^4$&$10^5$\\
            \cline{1-7}
            InsertionSort&0.001939&0.06914&6.65226&0.000017&0.000146&0.001397\\
            QuickSort&0.000377&0.001536&0.044997&0.011423&0.33125&31.01124\\
            HeapSort&0.000291&0.003594&0.009951&0.00008&0.000463&0.003292\\
            PlaceSort&0.009042&0.479786&41.534067&0.00707&0.230783&22.825008\\
            \cline{1-7}
        \end{tabular}
        \caption{Résultats empiriques de temps d'exécution}
    \end{figure}

    \subsection{Analyse des tests en fonction des complexités théoriques des différents algorithmes}
    \begin{enumerate}
        \item InsertionSort:
        \begin{itemize}
            \item croissant : L'InsertionSort n'est pas réputé 
            pour être un bon algorithme de tri pour des tableaux de grandes 
            tailles mais il a pour seul 
            avantage d'être très éfficace dans les cas où le tableau 
            est déjà trié ou presque. Ce cas croissant correspond donc 
            au meilleur cas de tableau pour cet algorithme où sa 
            complexité théorique est $\Theta (n)$. Si nous observons les 
            données de notre tableau, nous pouvons mettre en evidence le 
            fait que lorsque qu'un facteur 10 sépare la taille des tableaux 
            nous retrouvons effectivement ce facteur 10 au niveau du temps 
            d'exécution dû à notre complexité $\Theta (n)$. Par exemple, pour des tableaux de taille $10^3$ et 
            $10^4$, nous avons respectivement, en moyenne, 0.000146s et 0.001397s. 0.00146 se rapproche 
            très fortement de 0.001397.
             
            \item aléatoire : Le cas aléatoire correspond à un cas moyen pour 
            cet algorithme qui est $\Theta (n^2)$. Nous observons bien entre les 
            tableaux de tailles $10^3$ à $10^4$ ou de $10^4$ à $10^5$ un facteur $10^2$ séparant 
            nos moyennes temporelles.
        \end{itemize}
        \item QuickSort :
        \begin{itemize}
            \item croissant : Le cas croissant est un des pires cas 
            pour le QuickSort. En effet, celui-ci prend le dernier élément 
            du tableau et l'utilise comme valeur de pivot. Malheureusement, 
            le but de cet algorithme est de diviser le plus possible le tableau 
            afin de réduire la tableau en plus petit tableau à gérer, hors 
            dans le cas du cas croissant cette valeur de pivot sera toujours 
            la valeur la plus grande par rapport aux autres et ne permettra 
            pas de séparer le tableau en plusieurs tableaux qui permettrait 
            d'avoir la meilleure complexité possible pour des algorithmes de tri et notamment 
            celui-ci $\Theta (n*log(n))$. Dans ce cas-ci, la complexité 
            est $\Theta(n^2)$. Comme pour le cas aléatoire de l'InsertionSort, 
            un facteur $10^2$ sépare les moyennes de temps d'exécution 
            entre des tableaux de taille 10 fois plus grand.

            \item aléatoire :
        \end{itemize}
        \item HeapSort :
        \begin{itemize}
            \item croissant:
            \item aléatoire:
        \end{itemize}
    \end{enumerate}


    \section{\textbf{PlaceSort}}
    \subsection{Pseudo-code}
    \begin{lstlisting}
        PLACE(A)
            i=1
            while(i<=A.length)
                m=1
                for j=1 to A.length
                    if A[i]>A[j]
                        m = m + 1
                if m!=i
                    if A[i]==A[m]
                        while (A[i]==A[m])
                            m = m + 1
                        swap(A[i], A[m])
                        i = i + 1
                    else
                        swap(A[i], A[m])
                else
                    i = i + 1
    \end{lstlisting}



\end{document}